# blinkbus

## Мотивация

Мне нравится modbus. Нравится его концепция и простота. 
Мне нравится проводное подключение. Я не испытываю радиофобию, просто больше доверяю проводам.
Мне нравится децентрализованные и простые решения.
Я понимаю что по каждому пункту можно поспорить.

## Концепция

Каждый вход и выход, направление движение сигнала, промежуточное состояние, удалённое управление - всё можно контролировать через определённый регистр. Зашитая логика работы обеспечивает инструментарий. Конфигурация через регистры - взаимодействие инструментов.

Конечное исполнительное устройство, которое может контролировать назначенные ему зоны и сценарии не зависимо от присутствия внешнего управления. ~~Похоже я изобрёл ПЛК~~.

## Возможные сценарии использования

* Выключатель освещение с удалённым управлением
* Проходной выключатель на кнопке без фиксатора
* Одна кнопка на N каналов освещения
* Датчик движения который активирует приглушенное освещение 
* Датчик движения может быть удалённо заглушен (например по расписанию светового дня)
* Датчик движения может считываться удалённо даже если он заглушен (запись о том что кто-проходил в определённое время)
* Мастер включатель реализованный физически
* Мастер включатель активированный удалённо
* Пересекающиеся зоны освещения (один сенсор может подсвечивать несколько разных зон)
* Прямое управление pwm
* Удалённое управление во всех сценариях (например Home Assistant)

## Ограничения

Топология проводки. Проводка должна быть выполнена в виде лучей от распределительного шкафа до выключателей и ламп.

В данной реализации имеем всего по 8 штук. Входов, выходов, зон, сцен, жестов. На дом 100м2 придётся установить несколько устройств.

## Термины и блоки

* **Вход и выход** сигнала соотвествует конкретным пинам ардуино.
* **Уровень освещённости**. Для упрощения принято 4 уровня. Off, On и два промежуточных для работы с pwm.
* **Процессор зоны**. Блок который управляет поведением одной "зоны" освещения. Учитывает все входящие сигналы, хранит состояние и меняет его при необходимости.
* **Жест**. Определённая последовательность сигналов входа которая совпадает с заданными. Один клик. Двойной. Тройной. Долгий клик. Удерживание. Клик+Удерживание. При выполнении жеста может быть активирована сцена.
* **Сцена**. Заранее определённый набор зон или выходов.
* **Действие**. Действие применяется к сцене. Одна сцена может выполнятся с разными действиями. Включение. Выключение. Переключение. Ротация.

_На схеме изображены логические блоки, направление движение сигнала и обозначены регистры которые управляют ими._
![contr](docs/BLINKBUS_Control_Flow_&_Registers.svg)

## Настройка

Настройка сценария работы производится с помощью установки значений в соотвествующие регистры. Большинство настроек выглядят как битовая маска, где каждый бит соотвествут каналу выхода.

[Список всех регистров](docs/REGISTERS.md)

### Пример

Самый простой сценарий использования это сквозной проброс сигнала от входа к выходу. Такой маппинг выглядит как лесенка в битовом виде. 

![bit_ladder](docs/bit_ladder.png)

> [!TIP]
> На скриншоте ModbusPoll. Рекомендую использовать его при настройке и мониторинге. В репозитории приложены файлы в сессии mbp. Двойной клик по регистру откроет окно установки регистра. В нём можно будет задать значение побитово.

Выставляем следующие регистры в указанные значения:
```
10 = 1; 11 = 2; 12 = 4; 13 = 8; 14 = 16; 15 = 32; 16 = 64; 17 = 128
20 = 1; 21 = 2; 22 = 4; 23 = 8; 24 = 16; 25 = 32; 26 = 64; 27 = 128
```
Регистры 10-17 показывают то что каждый аналоговый вход отправляет сигнал на соответствующий процессор зоны. Регистры 20-27 показывают то что каждый процессор отправляет сигнал на соответствующий выход. В битовом представлении мы увидем ту самую лесенку. После этого сигнал будет проходить свободно от входа 1 к выходу 1. От входа 2 к выходу 2 и так далее.

Поменяем значение:

```
10 = 255
```

В битовом представлении это выглядит как 1111_1111. Читаем это следующим образом: Аналоговый вход 1 отпарвляет сигнал на все 8 процессоров. Поскольку ранее мы назначили каждому процессору свой выход получается первый вход будет управлять всеми выходами одновременно. ~~Назовём это мастер выключатель.~~

Регистр содержит 16 бит. В диапазоне 10-17 старший байт отражает влияние входа на процессор зоны в роли сенсора. Сенсор будет зажигать свет в режиме минимального свечения. Представим что у нас есть датчик движения в проходной комнате подключенный ко 2 входу. Установим значение регистра:
```
было
11 = 2 (0000_0000_0000_0010)
меняем на
11 = 1282 (0000_0101_0000_0010)
                 ^ ^
```
Таким образом мы говорим что вход 2 включает вторую зону на 100% и 1, 3 зону на 50%. Мы подсветили соседние зоны.

### Пример с жестом

Продолжаем работать с прошлой конфигурацией. Допустим у нас появились проходные выключатели на входах 3 и 4 которые дожны управлять освещением на выходе 8.

```
12 = 128 (1000_0000)
13 = 128 (1000_0000)
```

Но этот вариант потребует дополнительных кликов по выключателям чтобы привести их в одинаковое состояние. Не очень удобно. Для этого есть жесты. Выключаем прямое управление:

```
12 = 0 (0000_0000)
13 = 0 (0000_0000)
```

Аналоговые входы 3 и 4 ссылаются на жест №1:

```
32 = 1 (0000_0001)
33 = 1 (0000_0001)
```

Добавляем жест (один из восьми возможных) и сцену.

```
40 = 268 (0000_0001_0000_1100)
                          ^^^    Action::Toggle = 4
                         ^       apply to processor
                       ^         no rotation
                    ^^^          Gesture::OneClick = 0
          ^^^^ ^^^^              map to scene 1

50 = 32896  (1000_0000_1000_0000)
             ^         ^
       apply to ch8    ^
                  activate ch8
```

После этого входы 3 и 4 по клику активируют сцену 1 и применяют к ней действие **Toggle**

### Сохранение настроек

Регистр №0 является управляющим. В него можно записать номер команды и если она выполнится успешно региср примет значение 1.

Все настройки выше выполнялись с регистрами которые хранятся в оперативной памяти. Чтобы настройки не потерялись нужно сохранить регистры в **eeprom**. Сделать это можно записью в регистр №0 значения **734**. После этого при запуске arduino будет автоматически загружаться сохранённая конфигурация. 

Записью в регистр №0 значения **2** можно вернуть настройки по умолчанию.

### Настройка из кода

Ещё один вариант настройки это модификация кода **LoadConfigDefaults**. Это не так удобно так как потребует заливать скетч после каждой правки.

### Настройка соединения Modbus

Регистр 8 отвечает за номер устройства **slave**. Регистр 9 определяет скорость передачи. По умолчанию Id 1, 19200. После изменения значений необходимо сохранить настройки в **eeprom** и перезапустить arduino.

## Интеграция с Home Assistant

[Пример конфигурации Modbus](homeAssistant/configuration.yaml)

## Скетч

Тестировалось только на Arduino Nano, но есть уверенность что запустится и на старших моделях. Вместе с библиотекой modbus счкетч занимает 8398 байт (27%). Есть запас для какой либо RGB либы например.

Используемая библиотека modbus: https://github.com/EngDial/ModbusTCP . Нет жесткой привязки к этому варианту. Можно заменить на любую другую. Важно оставить конструкцию оформленную вокруг вызова **poll*. _Если есть идеи как пропихнуть регистры без memcpy предлагайте._

```
  uint16_t data[registers_count];
  memcpy(data, regs, sizeof(uint16_t)*registers_count);
  _anyPollingMethod_( data, registers_count );  
  memcpy(regs, data, sizeof(uint16_t)*registers_count);
```

Класс **BlinkBus** принимает один аргумент - это ссылка на **BBHardwareIO**. Абстракция которая читает и пишет пины arduino. Можно сделать свою имплементацию не влезая в основной код. **channel** в сигнатуре методов принимает значения от 0 до 7. Пример реализации можно посмотреть в **BasicHardwareIO**.

```
class BBHardwareIO {
  public:
  virtual bool ReadInput(uint8_t channel) = 0;
  virtual void WriteOutput(uint8_t channel, bool trigger, LightValue lv, uint8_t pwmLevel) = 0;
};

BasicHardwareIO hardwareIO; 
BlinkBus facade(&hardwareIO);
```

## Железо

![test stand](docs/test.jpg)
Входы и выходы развязаны через оптроны. ADC подтянуты к замле. Пример подключение одного входа и выхода:
![bit_ladder](docs/circuit.svg)
Конвертор уровня rs485 подключен к пинам D0, D1 (tx, rx)

